<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on 听雪者的博客</title>
    <link>https://cyberwave.github.io/categories/golang/</link>
    <description>Recent content in golang on 听雪者的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 03 Mar 2021 13:36:02 +0800</lastBuildDate><atom:link href="https://cyberwave.github.io/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2fa 双因素认证的Go实现</title>
      <link>https://cyberwave.github.io/post/2fa-auth-of-go/</link>
      <pubDate>Wed, 03 Mar 2021 13:36:02 +0800</pubDate>
      
      <guid>https://cyberwave.github.io/post/2fa-auth-of-go/</guid>
      <description>什么是2fa? 2fa，即 two-factor authentication，双因素认证。在登录网站及计算机系统时，使用两个不同的认证因素来证明自己。双因素认证依</description>
    </item>
    
    <item>
      <title>Go语言调度器的工作窃取</title>
      <link>https://cyberwave.github.io/post/Go-work-stealing-scheduler/</link>
      <pubDate>Mon, 01 Mar 2021 15:47:43 +0800</pubDate>
      
      <guid>https://cyberwave.github.io/post/Go-work-stealing-scheduler/</guid>
      <description>[译] Go&amp;rsquo;s work-stealing scheduler Go调度器的工作是在一个或多个处理器上运行的多个工作者OS线程上分发可运行的goroutine。在多线程计算中，调度中出现了两种</description>
    </item>
    
    <item>
      <title>Go的调度：第三部分 - 并发</title>
      <link>https://cyberwave.github.io/post/Scheduling-In-Go-3-Concurrency/</link>
      <pubDate>Sun, 28 Feb 2021 17:38:44 +0800</pubDate>
      
      <guid>https://cyberwave.github.io/post/Scheduling-In-Go-3-Concurrency/</guid>
      <description>[译] Scheduling In Go : Part III - Concurrency 序幕 这是分三部分的系列文章中的第三篇，它将提供对Go调度器背后的机制和语义的理解。这篇文章专注于并发。 三个部分系列的索</description>
    </item>
    
    <item>
      <title>Go的调度：第二部分 - Go调度器</title>
      <link>https://cyberwave.github.io/post/Scheduling-In-Go-2-GO-Scheduler/</link>
      <pubDate>Sat, 27 Feb 2021 14:15:42 +0800</pubDate>
      
      <guid>https://cyberwave.github.io/post/Scheduling-In-Go-2-GO-Scheduler/</guid>
      <description>[译] Scheduling In Go : Part II - Go Scheduler 序幕 这是一个由三部分组成的系列文章中的第二篇，它将提供对Go调度器背后的机制和语义的理解。这篇文章重点介绍Go调度器</description>
    </item>
    
    <item>
      <title>Go返回指针的坏处</title>
      <link>https://cyberwave.github.io/post/bad-go-of-return-pointer/</link>
      <pubDate>Sat, 27 Feb 2021 10:42:47 +0800</pubDate>
      
      <guid>https://cyberwave.github.io/post/bad-go-of-return-pointer/</guid>
      <description>[译] Bad Go: pointer returns 作为一个不再年轻的C程序员，我苦恼于一点：函数返回结构体的指针是完全正常的。但我感觉这是Go的坏处，通常我认为返回结构体的值会</description>
    </item>
    
    <item>
      <title>Go的调度：第一部分-OS调度</title>
      <link>https://cyberwave.github.io/post/Scheduling-In-Go-1-OS-Scheduler/</link>
      <pubDate>Wed, 24 Feb 2021 11:54:40 +0800</pubDate>
      
      <guid>https://cyberwave.github.io/post/Scheduling-In-Go-1-OS-Scheduler/</guid>
      <description>[译] Scheduling In Go : Part I - OS Scheduler 序幕 这是一个由三部分组成的系列文章的第一篇。它将提供对 Go 调度器背后的机制和语义的理解。这篇文章着重于操作系统调度器。</description>
    </item>
    
    <item>
      <title>Golang的可视化内存管理</title>
      <link>https://cyberwave.github.io/post/visualizing-memory-management-in-golang/</link>
      <pubDate>Thu, 04 Feb 2021 13:50:07 +0800</pubDate>
      
      <guid>https://cyberwave.github.io/post/visualizing-memory-management-in-golang/</guid>
      <description>原文：🚀 Visualizing memory management in Golang 在本章中， 我们将研究 Go 编程语言（golang）的内存管理。Go 是一种静态类型化和编译的语言，和 C/C++ 和 Rust一样。因此，Go</description>
    </item>
    
  </channel>
</rss>
